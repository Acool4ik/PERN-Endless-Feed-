{"version":3,"sources":["components/Loader.tsx","App.tsx","hooks/useAuth.tsx","hooks/useReader.ts","index.tsx"],"names":["ELoaderSize","ELoaderColor","Loader","isCircle","size","standert","color","yellow","className","App","useState","auth","setAuth","isAuth","IsAuthenticated","useCallback","children","redirectPath","React","Children","map","child","to","process","NotAuthenticated","useAuth","loadingReader","setLoadingReader","byte","setByte","BLOB_TO_FILE","blob","a","dictionary","nameRandom","i","length","charAt","Math","floor","random","file","File","type","lastModified","Date","now","FILE_TO_BLOB","Blob","FILE_OR_BLOB_TO_ARRAYBUFFER","data","arrayBuffer","FILE_OR_BLOB_TO_URL","URL","createObjectURL","FILE_OR_BLOB_TO_DataURL","callback","reader","FileReader","dataSize","onloadstart","e","loaded","onprogress","onloadend","onload","dataURL","target","result","readAsDataURL","errorMessage","message","Error","ARRAYBUFFER_TO_FILE","buffer","mimeType","uint8Array","Uint8Array","ARRAYBUFFER_TO_BLOB","ARRAYBUFFER_TO_URL","_URL","ARRAYBUFFER_TO_DataURL","URL_OR_DataURL_TO_FILE","fetch","response","URL_OR_DataURL_TO_BLOB","URL_OR_DataURL_TO_ARRAYBUFFER","DataURL_TO_URL","DataURL","URL_TO_DataURL","url","J","arrayColumnContainer","I","useReader","handler","files","B_TO_F","useEffect","console","log","path","onChange","onClick","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7c7523ae.chunk.js","sourcesContent":["import React from 'react'\r\n\r\nexport enum ELoaderSize {\r\n    big = 'big',\r\n    standert = '',\r\n    small = 'small'\r\n}\r\n\r\nexport enum ELoaderColor {\r\n    yellow = 'spinner-yellow-only',\r\n    green = 'spinner-green-only',\r\n    blue = 'spinner-red-only'\r\n}\r\n\r\ninterface ILoader {\r\n    children?: React.ReactNode,\r\n    isCircle?: boolean,\r\n    size?: ELoaderSize.big | ELoaderSize.standert | ELoaderSize.small,\r\n    color?: ELoaderColor.blue | ELoaderColor.green | ELoaderColor.yellow\r\n}\r\n\r\nexport const Loader: React.FC<ILoader> = (\r\n\r\n    {isCircle = true, size = ELoaderSize.standert, color = ELoaderColor.yellow}\r\n    \r\n) => (\r\n\r\n    isCircle ? \r\n    \r\n    <div className={`preloader-wrapper ${size} active`}>\r\n        <div className={`spinner-layer ${color}`}>\r\n            <div className=\"circle-clipper left\">\r\n                <div className=\"circle\"></div>\r\n            </div><div className=\"gap-patch\">\r\n                <div className=\"circle\"></div>\r\n            </div><div className=\"circle-clipper right\">\r\n                <div className=\"circle\"></div>\r\n            </div>\r\n        </div>\r\n    </div> \r\n     \r\n    :\r\n\r\n    <div className=\"progress\">\r\n       <div className=\"indeterminate\"></div>\r\n    </div>\r\n\r\n)","import React, { useState, useEffect } from 'react'\r\nimport { Route, BrowserRouter } from 'react-router-dom'\r\n\r\nimport {useAuth} from './hooks/useAuth'\r\nimport {useReader, IReader} from './hooks/useReader'\r\nimport {Loader} from './components/Loader'\r\n\r\n\r\n\r\nexport const App = () => {\r\n\tconst [auth, setAuth] = useState(true)\r\n\tconst [IsAuthenticated, NotAuthenticated] = useAuth(auth)\r\n\t\r\n\tconst {reader, loadingReader, byte} = useReader()\r\n\t\r\n\tconst handler = async (e: React.ChangeEvent<HTMLInputElement>) => {\r\n\t\tif(e.target.files![0]) {\r\n\t\t\tconst file = e.target.files![0]\r\n\t\t\tconst buffer = await file.arrayBuffer()\r\n\t\t\tconst _URL = URL.createObjectURL(file)\r\n\t\t\t\r\n\t\t\tconst B_TO_F = reader(5)(1) as IReader[5][1]\r\n\t\t\t\r\n            B_TO_F(file, () => {\r\n\t\t\t\t// console.log(dataURL)\r\n                // console.log(uehfef);\t\r\n\t\t\t})\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n\tuseEffect(() => {\r\n        console.log(`Status of load: ${loadingReader ? 'Loading...' : 'Loaded!'}`)\r\n\t}, [loadingReader])\r\n\r\n\tuseEffect(() => {\r\n\t\tconsole.log(`Loaded byte ${byte[0]} from ${byte[1]}`)\r\n\t}, [byte])\r\n\r\n\r\n\r\n    return (\r\n\t<BrowserRouter>\r\n\t<section className=\"container\">\r\n\t\t\r\n\t<IsAuthenticated redirectPath={'/'}>\r\n\t\t<Route path={'/'}>\r\n\t\t\t{/* <button onClick={handler}>\r\n\t\t\t\tshow get api\r\n\t\t\t</button> */}\r\n\t\t\t{/* <a ref={aaa} href=\"\" download> test </a> */}\r\n\t\t\t<input type=\"file\" onChange={handler} />\r\n\r\n\t\t\t{\r\n\t\t\t\tloadingReader && <Loader isCircle={false} />\r\n\t\t\t}\r\n\r\n\r\n\t\t</Route>\r\n\t</IsAuthenticated>\r\n\r\n\t<NotAuthenticated redirectPath={'/'}>\r\n\t\t<Route path={'/'} children={<button onClick={() => setAuth(true)}>not auth</button>} />\r\n\t</NotAuthenticated>\r\n\t\r\n\t</section>\r\n\t</BrowserRouter>\r\n    )\r\n}\r\n\r\n\r\n","import React, { useCallback } from 'react'\r\nimport { Switch, Redirect } from 'react-router-dom'\r\n\r\n\r\ninterface IAuth {\r\n    children: JSX.Element,\r\n    redirectPath: string\r\n}\r\n\r\ntype TAuthHandlers = (props: IAuth) =>  JSX.Element | null\r\ntype TUseAuth = (isAuth: boolean) => [TAuthHandlers, TAuthHandlers]\r\n\r\n\r\nexport const useAuth: TUseAuth = (isAuth = false) => { \r\n\r\n\r\n    const IsAuthenticated: TAuthHandlers = useCallback(({ \r\n        children = null, redirectPath = '/'\r\n    }) => {\r\n\r\n        if(isAuth) {\r\n            return <Switch>\r\n                \r\n                {\r\n                    React.Children.map(children, (child) => child)\r\n                }\r\n\r\n                <Redirect to={process.env.PUBLIC_URL + redirectPath} />\r\n            </Switch>\r\n        } else {\r\n            return null\r\n        }\r\n\r\n    }, [isAuth])\r\n\r\n\r\n\r\n    const NotAuthenticated: TAuthHandlers = useCallback(({ \r\n        children = null, redirectPath = '/'\r\n    }) => {\r\n\r\n        if(!isAuth) {\r\n            return <Switch>\r\n                \r\n                {\r\n                    React.Children.map(children, (child) => child)\r\n                }\r\n\r\n                <Redirect to={process.env.PUBLIC_URL + redirectPath} />\r\n            </Switch>\r\n        } else {\r\n            return null\r\n        }\r\n    }, [isAuth])\r\n\r\n\r\n\r\n    return [IsAuthenticated, NotAuthenticated]\r\n}\r\n","import {useCallback, useState} from 'react'\r\n\r\n\r\nexport interface IReader {\r\n    1: {\r\n        1: null, \r\n        2: (blob: Blob) => Promise<File>, \r\n        3: (buffer: ArrayBuffer, mimeType: string) => Promise<File>,\r\n        4: (data: string) => Promise<File>,\r\n        5: (data: string) => Promise<File>\r\n    },\r\n\r\n    2: {\r\n        1: (file: File) => Promise<Blob>, \r\n        2: null, \r\n        3: (buffer: ArrayBuffer, mimeType: string) => Promise<Blob>,\r\n        4: (data: string) => Promise<Blob>,\r\n        5: (data: string) => Promise<Blob>\r\n    },\r\n\r\n    3: {\r\n        1: (data: File | Blob) => Promise<ArrayBuffer>, \r\n        2: (data: File | Blob) => Promise<ArrayBuffer>, \r\n        3: null,\r\n        4: (data: string) => Promise<ArrayBuffer>,\r\n        5: (data: string) => Promise<ArrayBuffer>\r\n    },\r\n\r\n    4: {\r\n        1: (data: File | Blob) => Promise<string>, \r\n        2: (data: File | Blob) => Promise<string>, \r\n        3: (buffer: ArrayBuffer, mimeType: string) => Promise<string>,\r\n        4: null,\r\n        5: (DataURL: string) => Promise<string>\r\n    },\r\n\r\n    5: {\r\n        1: (data: File | Blob, callback: (DataURL: string, error?: Error | undefined) => void) => Promise<void>, \r\n        2: (data: File | Blob, callback: (DataURL: string, error?: Error | undefined) => void) => Promise<void>, \r\n        3: (buffer: ArrayBuffer, mimeType: string, callback: (DataURL: string, error?: Error | undefined) => void) => Promise<void>,\r\n        4: (url: string, callback: (DataURL: string, error?: Error | undefined) => void) => Promise<void>,\r\n        5: null\r\n    }\r\n}\r\n\r\n\r\nexport const useReader = () => {\r\n    // state of data\r\n    const [loadingReader, setLoadingReader] = useState<boolean>(false)\r\n    const [byte, setByte] = useState<[number, number]>([0, 0])\r\n    \r\n\r\n    \r\n    const reader = useCallback((J: number) => {\r\n        const arrayColumn_1 = [\r\n            null, BLOB_TO_FILE, ARRAYBUFFER_TO_FILE, URL_OR_DataURL_TO_FILE, URL_OR_DataURL_TO_FILE\r\n        ]\r\n    \r\n        const arrayColumn_2 = [\r\n            FILE_TO_BLOB, null, ARRAYBUFFER_TO_BLOB, URL_OR_DataURL_TO_BLOB, URL_OR_DataURL_TO_BLOB\r\n        ]\r\n    \r\n        const arrayColumn_3 = [\r\n            FILE_OR_BLOB_TO_ARRAYBUFFER, FILE_OR_BLOB_TO_ARRAYBUFFER, null, URL_OR_DataURL_TO_ARRAYBUFFER, URL_OR_DataURL_TO_ARRAYBUFFER\r\n        ]\r\n    \r\n        const arrayColumn_4 = [\r\n            FILE_OR_BLOB_TO_URL, FILE_OR_BLOB_TO_URL, ARRAYBUFFER_TO_URL, null, DataURL_TO_URL\r\n        ]\r\n    \r\n        const arrayColumn_5 = [\r\n            FILE_OR_BLOB_TO_DataURL, FILE_OR_BLOB_TO_DataURL, ARRAYBUFFER_TO_DataURL, URL_TO_DataURL, null\r\n        ]\r\n    \r\n        const arrayColumnContainer = [\r\n            arrayColumn_1,\r\n            arrayColumn_2,\r\n            arrayColumn_3,\r\n            arrayColumn_4,\r\n            arrayColumn_5\r\n        ]\r\n    \r\n        return (I: number) => {\r\n            if(I === J) { return null }\r\n            if(I > 5 || I < 1 || J > 5 || J < 1) { return null }\r\n            return arrayColumnContainer[J - 1][I - 1]\r\n        }\r\n    }, [])\r\n\r\n\r\n    ///////////////////////////\r\n    ////  BLOB & FILE = X  ////\r\n    ///////////////////////////\r\n    \r\n    // sync (f_1,1 - f_1,5) && (f_2,1 - f_2,5)\r\n    async function BLOB_TO_FILE(blob: Blob): Promise<File> {\r\n        const dictionary = 'qwertyuiopasdfgh' // 16 letters\r\n        let nameRandom: string = ''\r\n    \r\n        for (let i = 0; i < dictionary.length; i++) {\r\n            nameRandom += dictionary.charAt(Math.floor(Math.random() * dictionary.length))\r\n        }\r\n    \r\n        const file = new File([blob], nameRandom, { \r\n            type: blob.type,\r\n            lastModified: Date.now()\r\n        })\r\n    \r\n        return file\r\n    }\r\n    \r\n    async function FILE_TO_BLOB(file: File): Promise<Blob> {\r\n        const blob = new Blob([file], { type: file.type })\r\n        return blob\r\n    }\r\n    \r\n    async function FILE_OR_BLOB_TO_ARRAYBUFFER(data: File | Blob): Promise<ArrayBuffer> {\r\n        return await data.arrayBuffer()\r\n    }\r\n    \r\n    async function FILE_OR_BLOB_TO_URL(data: File | Blob): Promise<string> {\r\n        return URL.createObjectURL(data)\r\n    }\r\n    \r\n    // async --> callback is necessarily\r\n    async function FILE_OR_BLOB_TO_DataURL(\r\n        data: File | Blob, \r\n        callback: (DataURL: string, error?: Error) => void\r\n    \r\n    ): Promise<void> {\r\n        setLoadingReader(true)\r\n        const reader = new FileReader()\r\n        const dataSize = data.size\r\n\r\n        reader.onloadstart = (e) => setByte([e.loaded, dataSize])\r\n        reader.onprogress = (e) => setByte([e.loaded, dataSize])\r\n\r\n        reader.onloadend = () => {\r\n            setLoadingReader(false)\r\n            setByte([0, 0])\r\n        }\r\n    \r\n        try {\r\n            reader.onload = async (e: ProgressEvent<FileReader>) => {\r\n                const dataURL = e.target?.result as string\r\n                if(dataURL) {\r\n                    setByte([e.loaded, dataSize])\r\n                    await callback(dataURL)\r\n                }\r\n            }\r\n        \r\n            reader.readAsDataURL(data)\r\n        } catch(error) {\r\n            const errorMessage = error.message || 'Something going wrong...'\r\n            setLoadingReader(false)\r\n            setByte([0, 0])\r\n            await callback('', new Error(errorMessage))\r\n        }\r\n    }\r\n    \r\n    \r\n    ///////////////////////////\r\n    ////  ARRAYBUFFER = X  ////  \r\n    ///////////////////////////\r\n    \r\n    // sync (f_3,1 - f_3,5)\r\n    async function ARRAYBUFFER_TO_FILE(buffer: ArrayBuffer, mimeType: string): Promise<File> {\r\n        const dictionary = 'qwertyuiopasdfgh' // 16 letters\r\n        let nameRandom: string = ''\r\n    \r\n        for (let i = 0; i < dictionary.length; i++) {\r\n            nameRandom += dictionary.charAt(Math.floor(Math.random() * dictionary.length))\r\n        }\r\n    \r\n        const uint8Array = new Uint8Array(buffer)\r\n        const file = new File([uint8Array], nameRandom, { type: mimeType })\r\n    \r\n        return file\r\n    }\r\n    \r\n    async function ARRAYBUFFER_TO_BLOB(buffer: ArrayBuffer, mimeType: string): Promise<Blob> {\r\n        const uint8Array = new Uint8Array(buffer)\r\n        const blob = new Blob([uint8Array], { type: mimeType })\r\n    \r\n        return blob\r\n    }\r\n    \r\n    async function ARRAYBUFFER_TO_URL(buffer: ArrayBuffer, mimeType: string): Promise<string> {\r\n        const blob = new Blob([buffer], { type: mimeType })\r\n        const _URL = URL.createObjectURL(blob)\r\n    \r\n        return _URL\r\n    }\r\n    \r\n    // async --> callback is necessarily\r\n    async function ARRAYBUFFER_TO_DataURL(\r\n        buffer: ArrayBuffer, \r\n        mimeType: string, \r\n        callback: (DataURL: string, error?: Error) => void\r\n    \r\n    ): Promise<void> {\r\n        setLoadingReader(true)\r\n        const reader = new FileReader()\r\n        const blob = new Blob([buffer], { type: mimeType })\r\n        const dataSize = blob.size\r\n\r\n        reader.onloadstart = (e) => setByte([e.loaded, dataSize])\r\n        reader.onprogress = (e) => setByte([e.loaded, dataSize])\r\n\r\n        reader.onloadend = () => {\r\n            setLoadingReader(false)\r\n            setByte([0, 0])\r\n        }\r\n    \r\n        try {\r\n            reader.onload = async (e: ProgressEvent<FileReader>) => {\r\n                const dataURL = e.target?.result as string\r\n                if(dataURL) {\r\n                    setByte([e.loaded, dataSize])\r\n                    await callback(dataURL)\r\n                }\r\n            } \r\n    \r\n            reader.readAsDataURL(blob)\r\n        } catch(error) {\r\n            const errorMessage = error.message || 'Something going wrong...'\r\n            setLoadingReader(false)\r\n            setByte([0, 0])\r\n            await callback('', new Error(errorMessage))\r\n        }\r\n    }\r\n\r\n\r\n    /////////////////////////////\r\n    ////  URL & DataURL = X  ////\r\n    /////////////////////////////\r\n    \r\n    // sync (f_4,1 - f_4,5) && (f_5,1 - f_5,5)\r\n    async function URL_OR_DataURL_TO_FILE(data: string): Promise<File> {\r\n        const response = await fetch(data)\r\n        const blob = await response.blob()\r\n    \r\n        const dictionary = 'qwertyuiopasdfgh' // 16 letters\r\n        let nameRandom: string = ''\r\n    \r\n        for (let i = 0; i < dictionary.length; i++) {\r\n            nameRandom += dictionary.charAt(Math.floor(Math.random() * dictionary.length))\r\n        }\r\n    \r\n        return new File([blob], nameRandom, {type: blob.type})\r\n    }\r\n    \r\n    async function URL_OR_DataURL_TO_BLOB(data: string): Promise<Blob> {\r\n        const response = await fetch(data)\r\n        return await response.blob()\r\n    }\r\n    \r\n    async function URL_OR_DataURL_TO_ARRAYBUFFER(data: string): Promise<ArrayBuffer> {\r\n        const response = await fetch(data)\r\n        return await response.arrayBuffer()\r\n    }\r\n    \r\n    async function DataURL_TO_URL(DataURL: string): Promise<string> {\r\n        const response = await fetch(DataURL)\r\n        const blob = await response.blob()\r\n    \r\n        return URL.createObjectURL(blob)\r\n    }\r\n    \r\n    // async --> callback is necessarily\r\n    async function URL_TO_DataURL(url: string, callback: (DataURL: string, error?: Error) => void): Promise<void> {\r\n        const reader = new FileReader()\r\n    \r\n        try {\r\n            setLoadingReader(true)\r\n            const response = await fetch(url)\r\n            const blob = await response.blob()\r\n            const dataSize = blob.size\r\n\r\n            reader.onloadstart = (e) => setByte([e.loaded, dataSize])\r\n            reader.onprogress = (e) => setByte([e.loaded, dataSize])\r\n\r\n            reader.onloadend = () => {\r\n                setLoadingReader(false)\r\n                setByte([0, 0])\r\n            }\r\n            \r\n            reader.onload = async (e: ProgressEvent<FileReader>) => {\r\n                const dataURL = e.target?.result as string\r\n                if(dataURL) {\r\n                    setByte([e.loaded, dataSize])\r\n                    await callback(dataURL)\r\n                }\r\n            } \r\n    \r\n            reader.readAsDataURL(blob)\r\n        } catch(error) {\r\n            const errorMessage = error.message || 'Something going wrong...'\r\n            setLoadingReader(false)\r\n            setByte([0, 0])\r\n            await callback('', new Error(errorMessage))   \r\n        }\r\n    }\r\n        \r\n        \r\n    return {\r\n        // reader of data\r\n        reader,\r\n\r\n        // state of data\r\n        loadingReader,\r\n        byte\r\n    }\r\n}\r\n","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\nimport 'materialize-css'\r\nimport './index.css'\r\nimport { App } from './App'\r\n\r\n\r\nReactDOM.render(\r\n\r\n    <React.StrictMode>\r\n        <App />\r\n    </React.StrictMode>,\r\n    \r\n    document.getElementById('root')\r\n)\r\n\r\n"],"sourceRoot":""}